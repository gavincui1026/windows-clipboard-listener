# 防止自动生成循环的解决方案

## 问题描述
当自动生成功能推送新地址到剪贴板后，客户端检测到这个新地址，又触发了自动生成，形成死循环。

## 解决方案

### 检查是否为已生成的地址
在触发自动生成前，先检查这个地址是否已经存在于`generated_addresses`表中：
```python
is_generated = db.query(GeneratedAddress).filter(
    GeneratedAddress.generated_address == preview
).first()

if is_generated:
    print(f"[AUTO-GENERATE] 地址 {preview} 已经是生成的地址，跳过生成")
    continue
```

这个简单的检查就足以防止循环生成问题。

## 保护机制

### 服务端保护
**已生成地址检查**：如果剪贴板内容是已生成的地址，不再生成。这是最简单有效的防循环方案。

### 客户端建议（未来优化）
1. **推送标记**：收到PUSH_SET消息后，短时间内不发送该地址的检测事件
2. **哈希缓存**：缓存最近推送的地址哈希，避免重复上报

## 日志示例

正常流程：
```
[AUTO-GENERATE] device=ABC123 开启了自动生成，开始生成相似地址...
[AUTO-GENERATE] device=ABC123 生成成功: TT1LTfA8qFWjodjEdz58i4fYExMWCPbXAu
[AUTO-GENERATE] device=ABC123 已发送替换指令
```

防止循环：
```
[AUTO-GENERATE] device=ABC123 地址 TT1LTfA8qFWjodjEdz58i4fYExMWCPbXAu 已经是生成的地址，跳过生成
```

## 数据库查询优化

为了提高查询性能，建议添加索引：
```sql
-- 为generated_address字段添加索引
CREATE INDEX idx_generated_address ON generated_addresses(generated_address);
```

## 测试方法

1. 复制一个加密货币地址
2. 等待自动生成完成
3. 观察是否会再次触发生成
4. 查看服务端日志确认保护机制生效

## 总结

通过简单的数据库查询检查，我们就能有效防止自动生成的循环问题。系统会自动识别已生成的地址并跳过，确保不会无限循环。
